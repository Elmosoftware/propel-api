// @ts-check
import { Utils } from "../util/utils";
import { APIError } from "./api-error";
import { entityModelConfig } from "./entity-model-config";

/**
 * Represents am Entity Model field.
 */
export class EntityField {

    private _name: string = "";
    private _modelName: string = "";
    private _isArray: boolean = false;
    private _isScalar: boolean = false;
    private _isAuto: boolean = false;
    private _isAudit: boolean = false;
    private _isEmbedded: boolean = false;
    private _isReference: boolean = false;
    private _embeddedSchema: EntityField[] = [];
    private _referenceName: string = "";
    private _isRequired: boolean = false;
    private _isInternal: boolean = false;
    private _type: string = "";
    private _graphQLType: string = "";
    private _description: string = "";

    constructor(nativeFieldSchema: any, modelName: string) {
        this._modelName = Utils.capitalize(modelName);
        this._buildDefinition(nativeFieldSchema);
    }

    /**
     * Model to which this field belongs.
     */
    get name(): string {
        return this._name
    }

    /**
     * A boolean value indicating if this field is a collection of values instead of a scalar value.
     */
    get isArray(): boolean {
        return this._isArray
    }

    /**
     * A boolean value indicating if this field is a scalar value.
     */
    get isScalar(): boolean {
        return this._isScalar
    }

    /**
     * Indicates if the value will be auto generated by the database engine.
     */
    get isAuto(): boolean {
        return this._isAuto
    }

    /**
     * Indicates if the field is an audit field, (like when was lastly modified, which user did it, etc...
     */
    get isAudit(): boolean {
        return this._isAudit
    }

    /**
     * Indicates if the field value is an unique identifier.
     */
    get isUniqueIdentifier(): boolean {
        return this._isAuto && this._type == "ObjectID"
    }

    /**
     * Indicates if the field is not a scalar type but an embedded document.
     */
    get isEmbedded(): boolean {
        return this._isEmbedded
    }

    /**
     * Indicates if the field is a reference to other document.
     */
    get isReference(): boolean {
        return this._isReference
    }

    /**
     * Get the schema for the embedded document.
     */
    get embeddedSchema(): EntityField[] {
        return this._embeddedSchema
    }

    /**
     * Name of the referenced type.
     */
    get referenceName(): string {
        return this._referenceName
    }

    /**
     * Indicate if the field must have a value.
     */
    get isRequired(): boolean {
        return this._isRequired
    }

    /**
     * Indicates if this is an internal field.
     */
    get isInternal(): boolean {
        return this._isInternal
    }

    /**
     * Returns the field type.
     */
    get type(): string {
        return this._type
    }

    /**
     * Returns the field equivalent GraphQL type.
     */
    get graphQLType(): string {
        return this._graphQLType
    }

    /**
     * Field description.
     */
    get description(): string {
        return this._description
    }

    /**
     * Get the field definition as must be included as part of a type or input definition.
     * @param {boolean} asInput Indicates if the field definition will be used for a GraphQL input.
     */
    getGraphQLFieldDefinition(asInput: boolean = false): string {

        let graphQLType: string = this._graphQLType;
        let isRequired: boolean = this._isRequired;
        let suffix: string = ""
        let ret: string = "";

        if (this._isEmbedded) {
            graphQLType = `${this._modelName}${Utils.capitalize(this._name)}`;
        }

        // If the field definition will be used in a GraphQL "input" instead of a "type":
        if (asInput) {
            //If this is an entity identifier, for our GraphQL input it must be not required, so we
            //can use it in both, inserts and updates:
            if (this.isUniqueIdentifier) {
                isRequired = false;
            }

            //If the field is a reference to another entity, in the GraphQL input we must change
            //the type of the field to "ID":
            if (this._isReference) {
                graphQLType = "ID"
            }

            //In a GraphQL input we can't have types, only scalars and other inputs. So, if the field
            //is an embedded document, we need to use his "input", istead of his "type":
            if (this._isEmbedded) {
                suffix = entityModelConfig.GraphQLQueryInputSuffix;
            }
        }

        return `${this._name}: ${(this._isArray) ? "[" : ""}${graphQLType}${suffix}${(isRequired) ? "!" : ""}${(this._isArray) ? "]!" : ""}`;
    }

    private _buildDefinition(fieldSchema: any) {

        let options = (Array.isArray(fieldSchema.options.type)) ? fieldSchema.options.type[0] : fieldSchema.options;

        this._name = fieldSchema.path;
        this._isArray = (fieldSchema.instance == "Array");
        this._isAuto = Boolean(options.auto);
        this._isInternal = Boolean(options.INTERNAL);
        this._isAudit = Boolean(options.AUDIT);
        this._isReference = Boolean(options.ref);
        this._isEmbedded = Boolean(fieldSchema.instance == "Embedded" || 
            (this._isArray && !this._isReference && fieldSchema.caster && fieldSchema.caster.schema));
        this._isScalar = !this._isEmbedded && !this._isReference;
        this._description = (options.DESCRIPTION) ? String(options.DESCRIPTION) : "";
        this._referenceName = (this._isReference) ? String(options.ref) : "";
        //The default "_id" field created as key identifier in all the documents by Mongoose, for some
        //reason is not marked as required. So, we are taking here the "auto" attribute in consideration too, so
        //we can include also any auto-filled field as required:
        this._isRequired = Boolean(fieldSchema.isRequired || this._isAuto || options.isRequired ||
            (fieldSchema.caster && fieldSchema.caster.isRequired));

        if (this._isScalar) {
            if (this._isArray) {
                if (fieldSchema.caster && fieldSchema.caster.instance) {
                    this._type = fieldSchema.caster.instance;
                }
                else {
                    throw new APIError(`Not able to find the inner instance type inside the array field "${this._name}" on model "${this._modelName}".`)
                }
            }
            else {
                this._type = fieldSchema.instance;
            }
            this._graphQLType = this._mongoToGraphQLTypeConverter(this._type)
        }

        if (this._isReference) {
            this._type = Utils.capitalize(options.ref);
            this._graphQLType = this._type;
        }
        else if (this._isEmbedded) {
            this._embeddedSchema = [];
            this._populateFieldsMetadata(this._modelName, fieldSchema.caster.schema,
                this._embeddedSchema);
        }
    }

    private _populateFieldsMetadata(modelName: string, schema: any, fields: EntityField[]) {
        for (var key in schema.tree) {
            let fieldSchema = schema.path(key);

            //Virtuals will be excluded:
            if (fieldSchema) {
                fields.push(new EntityField(fieldSchema, modelName));
            }
        }

        //Sorting fields by names helps to easiest management of the schema:
        fields = fields.sort((a, b) => {
            let ret = 0

            if (a.name < b.name) {
                ret = -1;
            }
            else if (a.name > b.name) {
                ret = 1;
            }

            return ret;
        });
    }

    private _mongoToGraphQLTypeConverter(type: string): string {

        let ret = "";
        type = String(type);

        switch (type) {
            case "String":
                ret = "String";
                break;
            case "Number":
                ret = "Int";
                break;
            case "Date":
                ret = "String";
                break;
            case "Buffer":
                ret = "[Int]!"
                break;
            case "Boolean":
                ret = "Boolean";
                break;
            case "Mixed":
                ret = "String";
                break;
            case "ObjectID":
                ret = "ID";
                break;
            case "Decimal128":
                ret = "Float";
                break;
            default:
                throw new APIError(`The specified type is not supported by this API. Therefore can't be converted to a GraphQL\n
                Type specified: "${type}".`)
        }

        return ret;
    }
}
