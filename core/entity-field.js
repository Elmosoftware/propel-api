// @ts-check

const Utils = require("../util/utils")
const APIError = require("./api-error");
const emc = require("./entity-model-config");

/**
 * Represents am Entity Model field.
 */
class EntityField {

    constructor(nativeFieldSchema, modelName) {
        this._internal = {
            name: "",
            modelName: Utils.capitalize(modelName),
            isArray: false,
            isScalar: false,
            isAuto: false,
            isAudit: false,
            isEmbedded: false,
            isReference: false,
            embeddedSchema: null,
            referenceName: "",
            isRequired: false,
            isInternal: false,
            type: null,
            graphQLType: null,
            description: ""
        }

        this._buildDefinition(nativeFieldSchema);
        this._internal = Object.freeze(this._internal);
    }

    /**
     * Model to which this field belongs.
     */
    get name() {
        return this._internal.name
    }

    /**
     * A boolean value indicating if this field is a collection of values instead of a scalar value.
     */
    get isArray() {
        return this._internal.isArray
    }

    /**
     * A boolean value indicating if this field is a scalar value.
     */
    get isScalar() {
        return this._internal.isScalar
    }

    /**
     * Indicates if the value will be auto generated by the database engine.
     */
    get isAuto() {
        return this._internal.isAuto
    }

    /**
     * Indicates if the field is an audit field, (like when was lastly modified, which user did it, etc...
     */
    get isAudit() {
        return this._internal.isAudit
    }

    /**
     * Indicates if the field value is an unique identifier.
     */
    get isUniqueIdentifier() {
        return this.isAuto && this.type == "ObjectID"
    }

    /**
     * Indicates if the field is not a scalar type but an embedded document.
     */
    get isEmbedded() {
        return this._internal.isEmbedded
    }

    /**
     * Indicates if the field is a reference to other document.
     */
    get isReference() {
        return this._internal.isReference
    }

    /**
     * Get the schema for the embedded document.
     */
    get embeddedSchema() {
        return this._internal.embeddedSchema
    }

    /**
     * Name of the referenced type.
     */
    get referenceName() {
        return this._internal.referenceName
    }

    /**
     * Indicate if the field must have a value.
     */
    get isRequired() {
        return this._internal.isRequired
    }

    /**
     * Indicates if this is an internal field.
     */
    get isInternal() {
        return this._internal.isInternal
    }

    /**
     * Returns the field type.
     */
    get type() {
        return this._internal.type
    }

    /**
     * Returns the field equivalent GraphQL type.
     */
    get graphQLType() {
        return this._internal.graphQLType
    }

    /**
     * Field description.
     */
    get description() {
        return this._internal.description
    }

    /**
     * Get the field definition as must be included as part of a type or input definition. 
     * @param {boolean} asInput Indicates if the field definition will be used for a GraphQL input.
     */
    getGraphQLFieldDefinition(asInput = false) {

        let graphQLType = this._internal.graphQLType;
        let isRequired = this._internal.isRequired;
        let suffix = ""
        let ret = "";

         //Internal fields don't have to be included in the model schema:
         if (!this._internal.isInternal) {
            if (this._internal.isEmbedded) {
                graphQLType = `${this._internal.modelName}${Utils.capitalize(this._internal.name)}`;
            }

            // If the field definition will be used in a GraphQL "input" instead of a "type":
            if (asInput) {
                //If this is an entity identifier, for our GraphQL input it must be not required, so we 
                //can use it in both, inserts and updates:                
                if(this._internal.isUniqueIdentifier) {
                    isRequired = false;
                }

                //If the field is a reference to another entity, in the GraphQL input we must change 
                //the type of the field to "ID":
                if (this._internal.isReference) {
                    graphQLType = "ID"
                }

                //In a GraphQL input we can't have types, only scalars and other inputs. So, if the field 
                //is an embedded document, we need to use his "input", istead of his "type":
                if (this._internal.isEmbedded) {
                    suffix = emc.GraphQLQueryInputSuffix;
                }
            }
            
            ret = `${this._internal.name}: ${(this._internal.isArray) ? "[" : ""}${graphQLType}${suffix}${(this._internal.isRequired) ? "!" : ""}${(this._internal.isArray) ? "]!" : ""}`
        }

        return ret;
    }

    _populateFieldsMetadata(modelName, schema, fields) {
        for (var key in schema.tree) {
            let fieldSchema = schema.path(key);

            //Virtuals will be excluded:
            if (fieldSchema) {
                fields.push(new EntityField(fieldSchema, modelName));
            }
        }

        //Sorting fields by names helps to easiest management of the schema:
        fields = fields.sort((a, b) => {
            let ret = 0

            if (a.name < b.name) {
                ret = -1;
            }
            else if (a.name > b.name) {
                ret = 1;
            }

            return ret;
        });
    }

    _buildDefinition(fieldSchema) {

        let options = (Array.isArray(fieldSchema.options.type)) ? fieldSchema.options.type[0] : fieldSchema.options;

        this._internal.name = fieldSchema.path;
        this._internal.isArray = (fieldSchema.instance == "Array");
        this._internal.isScalar = !this._internal.isArray && fieldSchema.instance != "Embedded";
        // options = (Array.isArray(fieldSchema.options.type)) ? fieldSchema.options.type[0] : fieldSchema.options;
        this._internal.isAuto = Boolean(options.auto);
        this._internal.isInternal = Boolean(options.INTERNAL);
        this._internal.isAudit = Boolean(options.AUDIT);
        this._internal.isEmbedded = fieldSchema.instance == "Embedded" ||
            (this._internal.isArray && !options.ref);
        this._internal.isReference = Boolean(options.ref);
        this._internal.description = (options.DESCRIPTION) ? String(options.DESCRIPTION) : "";
        this._internal.referenceName = (this._internal.isReference) ? String(options.ref) : "";
        //The default "_id" field created as key identifier in all the documents by Mongoose, for some 
        //reason is not marked as required. So, we are taking here the "auto" attribute in consideration too, so 
        //we can include also any auto-filled field as required:
        this._internal.isRequired = Boolean(fieldSchema.isRequired || this._internal.isAuto || options.isRequired || 
            (fieldSchema.caster && fieldSchema.caster.isRequired));

        if (this._internal.isScalar) {
            this._internal.type = fieldSchema.instance;
            this._internal.graphQLType = this._mongoToGraphQLTypeConverter(this._internal.type)   
        }

        if (this._internal.isReference) {
            this._internal.type = Utils.capitalize(options.ref);
            this._internal.graphQLType = this._internal.type;
        }
        else if (this._internal.isEmbedded) {
            this._internal.embeddedSchema = [];
            this._populateFieldsMetadata(this._internal.modelName, fieldSchema.caster.schema, 
                this._internal.embeddedSchema);
        }
    }

    _mongoToGraphQLTypeConverter(type) {

        let ret = "";
        type = String(type);

        switch (type) {
            case "String":
                ret = "String";
                break;
            case "Number":
                ret = "Int";
                break;
            case "Date":
                ret = "String";
                break;
            case "Buffer":
                ret = "[Int]!"
                break;
            case "Boolean":
                ret = "Boolean";
                break;
            case "Mixed":
                ret = "String";
                break;
            case "ObjectID":
                ret = "ID";
                break;
            case "Decimal128":
                ret = "Float";
                break;
            default:
                throw new APIError(`The specified type is not supported by this API. Therefore can't be converted to a GraphQL\n
                Type specified: "${type}".`)
        }

        return ret;
    }
}

module.exports = EntityField
